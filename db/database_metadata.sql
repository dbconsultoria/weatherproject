-- ==============================
-- DROP TABLES in dependency order
-- ==============================

-- 1. Tabelas sem dependências diretas
DROP TABLE IF EXISTS stage.weathervc;
DROP TABLE IF EXISTS fact.temperature;
DROP TABLE IF EXISTS dim.city;
DROP TABLE IF EXISTS dim.conditions;
DROP TABLE IF EXISTS dim.date;
DROP TABLE IF EXISTS dim.country;

-- ==============================
-- DROP SCHEMAS (se estiverem vazios)
-- ==============================
DROP SCHEMA IF EXISTS stage CASCADE;
DROP SCHEMA IF EXISTS fact CASCADE;
DROP SCHEMA IF EXISTS dim CASCADE;

-- Criação dos schemas
CREATE SCHEMA IF NOT EXISTS dim;
CREATE SCHEMA IF NOT EXISTS fact;
CREATE SCHEMA IF NOT EXISTS stage;

-- =======================================
-- CREATE TABLE dim.country (independente)
-- =======================================
CREATE TABLE dim.country (
    country_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_name VARCHAR NOT NULL UNIQUE
);


-- =======================================
-- CREATE TABLE dim.date (independente)
-- =======================================
CREATE TABLE dim.date (
    date_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    full_date DATE NOT NULL UNIQUE,
    year INTEGER,
    month INTEGER,
    day INTEGER,
    weekday INTEGER,
    is_weekend BOOLEAN
);

-- =======================================
-- CREATE TABLE dim.conditions (independente)
-- =======================================
CREATE TABLE dim.conditions (
    condition_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    condition_name VARCHAR NOT NULL UNIQUE,
    description TEXT
);

-- =======================================
-- CREATE TABLE dim.city (depende de country)
-- =======================================
CREATE TABLE dim.city (
    city_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    city_name VARCHAR NOT NULL UNIQUE,
    country_id INTEGER,
    FOREIGN KEY (country_id) REFERENCES dim.country(country_id)
);

-- =======================================
-- CREATE TABLE fact.temperature 
-- (depende de date, city, conditions)
-- =======================================
CREATE TABLE fact.temperature (
    temperature_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    date_id INTEGER,
    city_id INTEGER,
    condition_id INTEGER,
    temp REAL,
    insert_time TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (date_id) REFERENCES dim.date(date_id),
    FOREIGN KEY (city_id) REFERENCES dim.city(city_id),
    FOREIGN KEY (condition_id) REFERENCES dim.conditions(condition_id),
    CONSTRAINT uq_fact_temperature_date_city UNIQUE (date_id, city_id)
);

-- =======================================
-- CREATE TABLE stage.weathervc (independente)
-- =======================================
CREATE TABLE stage.weathervc (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    city VARCHAR NOT NULL,
    country VARCHAR DEFAULT 'Brazil',
    date DATE NOT NULL,
    temp REAL,
    conditions VARCHAR,
    description VARCHAR,
    insert_time TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP
);


-- =======================================
-- STORED PROCEDURES AND FUNCTIONS
-- =======================================

-- public.a (PROCEDURE)
-- Language: plpgsql, Returns: None
CREATE OR REPLACE PROCEDURE public.a()
 LANGUAGE plpgsql
AS $procedure$

DECLARE

    d DATE := '2000-01-01';

    end_date DATE := '2099-01-01';

BEGIN

    WHILE d <= end_date LOOP

        INSERT INTO dim.date (full_date, year, month, day, weekday, is_weekend)

        VALUES (

            d,

            EXTRACT(YEAR FROM d),

            EXTRACT(MONTH FROM d),

            EXTRACT(DAY FROM d),

            EXTRACT(DOW FROM d),

            EXTRACT(DOW FROM d) IN (0, 6)  -- Sunday = 0, Saturday = 6

        )

        ON CONFLICT (full_date) DO NOTHING;



        d := d + INTERVAL '1 day';

    END LOOP;



    RAISE NOTICE '✅ dim.date populated from 2000-01-01 to 2099';

END;

$procedure$

-- public.load_dim_city (PROCEDURE)
-- Language: plpgsql, Returns: None
CREATE OR REPLACE PROCEDURE public.load_dim_city()
 LANGUAGE plpgsql
AS $procedure$

BEGIN

    INSERT INTO dim.city (city_name, country_id)

    SELECT DISTINCT

        s.city,

        c.country_id

    FROM stage.weathervc s

    JOIN dim.country c ON c.country_name = s.country

    WHERE s.city IS NOT NULL

    ON CONFLICT (city_name) DO NOTHING;



    RAISE NOTICE '✅ dim.city populated successfully.';

END;

$procedure$

-- public.load_dim_conditions (PROCEDURE)
-- Language: plpgsql, Returns: None
CREATE OR REPLACE PROCEDURE public.load_dim_conditions()
 LANGUAGE plpgsql
AS $procedure$

BEGIN

    INSERT INTO dim.conditions (condition_name, description)

    SELECT DISTINCT

        conditions,

        description

    FROM stage.weathervc

    WHERE conditions IS NOT NULL

    ON CONFLICT (condition_name) DO NOTHING;



    RAISE NOTICE '✅ dim.conditions populated successfully.';

END;

$procedure$

-- public.load_dim_country (PROCEDURE)
-- Language: plpgsql, Returns: None
CREATE OR REPLACE PROCEDURE public.load_dim_country()
 LANGUAGE plpgsql
AS $procedure$

BEGIN

    INSERT INTO dim.country (country_name)

    SELECT DISTINCT country

    FROM stage.weathervc

    WHERE country IS NOT NULL

    ON CONFLICT (country_name) DO NOTHING;

    

    RAISE NOTICE '✅ dim.country populated successfully.';

END;

$procedure$

-- public.load_dim_date (PROCEDURE)
-- Language: plpgsql, Returns: None
CREATE OR REPLACE PROCEDURE public.load_dim_date()
 LANGUAGE plpgsql
AS $procedure$

DECLARE

    d DATE := '2000-01-01';

    end_date DATE := '2099-01-01';

BEGIN

    WHILE d <= end_date LOOP

        INSERT INTO dim.date (full_date, year, month, day, weekday, is_weekend)

        VALUES (

            d,

            EXTRACT(YEAR FROM d),

            EXTRACT(MONTH FROM d),

            EXTRACT(DAY FROM d),

            EXTRACT(DOW FROM d),

            EXTRACT(DOW FROM d) IN (0, 6)  -- Sunday = 0, Saturday = 6

        )

        ON CONFLICT (full_date) DO NOTHING;



        d := d + INTERVAL '1 day';

    END LOOP;



    RAISE NOTICE '✅ dim.date populated from 2000-01-01 to %', end_date;

END;

$procedure$

-- public.merge_fact_temperature (PROCEDURE)
-- Language: plpgsql, Returns: None
CREATE OR REPLACE PROCEDURE public.merge_fact_temperature()
 LANGUAGE plpgsql
AS $procedure$

BEGIN

    INSERT INTO fact.temperature (date_id, city_id, condition_id, temp)

    SELECT

        d.date_id,

        ci.city_id,

        co.condition_id,

        s.temp

    FROM stage.weathervc s

    JOIN dim.date d ON d.full_date = s.date

    JOIN dim.city ci ON ci.city_name = s.city

    JOIN dim.conditions co ON co.condition_name = s.conditions

    WHERE s.temp IS NOT NULL

    ON CONFLICT (date_id, city_id) DO UPDATE

    SET

        condition_id = EXCLUDED.condition_id,

        temp = EXCLUDED.temp,

        insert_time = CURRENT_TIMESTAMP;



    RAISE NOTICE '✅ fact.temperature merged successfully.';

END;

$procedure$

